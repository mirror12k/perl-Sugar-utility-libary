
class Sugar::Lang::SugarGrammarCompiler {

sub _constructor (tree args) {
	# my ($class, %opts) = @_;
	# my $self = bless {}, $class;

	if (contains args.compile_standalone) {
		self.compile_standalone = args.compile_standalone;
	} else {
		self.compile_standalone = 0;
	}

	if (contains args.syntax_definition_intermediate) {
		self.load_syntax_definition_intermediate(args.syntax_definition_intermediate);
	} else {
		# TODO: croak
		die "syntax_definition_intermediate argument required for Sugar::Lang::SugarGrammarCompiler";
	}

	# $self->{syntax_definition_intermediate} = $opts{syntax_definition_intermediate}
	# 		// croak "syntax_definition_intermediate argument required for Sugar::Lang::SyntaxIntermediateCompiler";

	# $self->{variables} = $self->{syntax_definition_intermediate}{variables};
	# $self->{variables_by_name} = {};
	# $self->{tokens} = [];
	# $self->{ignored_tokens} = $self->{syntax_definition_intermediate}{ignored_tokens};
	# $self->{context_order} = $self->{syntax_definition_intermediate}{context_order};
	# $self->{item_contexts} = $self->{syntax_definition_intermediate}{item_contexts};
	# $self->{list_contexts} = $self->{syntax_definition_intermediate}{list_contexts};
	# $self->{object_contexts} = $self->{syntax_definition_intermediate}{object_contexts};
	# $self->{subroutine_order} = $self->{syntax_definition_intermediate}{subroutine_order};
	# $self->{subroutines} = $self->{syntax_definition_intermediate}{subroutines};
	# $self->{code_definitions} = {};
	# $self->{package_identifier} = $self->{syntax_definition_intermediate}{package_identifier} // 'PACKAGE_NAME';
	# $self->compile_syntax_intermediate;

	# return self;
}

void sub load_syntax_definition_intermediate (tree intermediate) {
	self.syntax_definition_intermediate = intermediate;

	self.global_variable_names = self.syntax_definition_intermediate.global_variable_names;
	self.global_variable_expressions = self.syntax_definition_intermediate.global_variable_expressions;
	self.variables_scope = { '$_' => '$context_value' };
	self.tokens_scope_count = 0;
	self.token_definitions = [];
	self.ignored_tokens = self.syntax_definition_intermediate.ignored_tokens;
	self.contexts = self.syntax_definition_intermediate.contexts;
	self.contexts_by_name = self.syntax_definition_intermediate.contexts_by_name;
	self.subroutines = self.syntax_definition_intermediate.subroutines;
	self.code_definitions = {};

	# TODO: // expression
	if (contains self.syntax_definition_intermediate.package_identifier) {
		self.package_identifier = self.syntax_definition_intermediate.package_identifier;
	} else {
		self.package_identifier = 'PACKAGE_NAME';
	}
}

string sub to_package () {

	string code = '';
	# my $code = '';

	code += "#!/usr/bin/env perl
package $self.package_identifier;
";

	if (self.compile_standalone == 0) {
		code += "use parent 'Sugar::Lang::BaseSyntaxParser';\n";
	}

	code += "use strict;
use warnings;

use feature 'say';



";

	code += "\n\n##############################\n##### variables and settings\n##############################\n\n";


	if (0 < list length self.global_variable_names) {
		foreach (string key in self.global_variable_names) {
			string value = self.global_variable_expressions[key];
			code += "our \$var_$key = $value;\n";
		}
	}
	code += "\n\n";

	code += "our \$tokens = [\n";
	if (0 < list length self.token_definitions) {
		foreach (tree token_definition in self.token_definitions) {
			code += "\t'$token_definition.key' => $token_definition.value,\n";
		}
	}
	code += "];\n\n";

	code += "our \$ignored_tokens = [\n";
	foreach (string token in self.ignored_tokens) {
		code += "\t'$token',\n";
	}
	code += "];\n\n";

	code += "our \$contexts = {\n";
	foreach (tree context in self.contexts) {
		code += "\t$context.identifier => 'context_$context.identifier',\n";
	}
	code += "};\n\n";

	code += "\n\n##############################\n##### api\n##############################\n\n";


	if (self.compile_standalone) {
		code += self.get_standalone_functionality();
	} else {
			code += '

sub new {
	my ($class, %opts) = @_;

	$opts{token_regexes} = $tokens;
	$opts{ignored_tokens} = $ignored_tokens;
	$opts{contexts} = $contexts;

	my $self = $class->SUPER::new(%opts);

	return $self
}

sub parse {
	my ($self, @args) = @_;
	return $self->SUPER::parse(@args)
}

';
	}

	code += "\n\n##############################\n##### sugar contexts functions\n##############################\n\n";

	foreach (tree context in self.contexts) {
		code += self.code_definitions[context.identifier];
		# my $identifier = $context->{identifier};
		# code += $self->{code_definitions}{$identifier} =~ s/\A(\s*)sub \{/$1sub context_$identifier {/r;
	}

	code += "\n\n##############################\n##### native perl functions\n##############################\n\n";

	foreach (tree subroutine in self.subroutines) {
		string subroutine_code = subroutine.code_block;
		# todo: match index variables in string substitution
		subroutine_code = subroutine_code =~ s/\A\{\{(.*)\}\}\Z/{$1}/s;
		code += "sub $subroutine.identifier $subroutine_code\n\n";

		code += "caller or main(\@ARGV);\n\n" if subroutine.identifier == 'main';
	}

	code += "\n\n1;\n\n";

	return code;
}

void sub confess_at_current_line (string msg) {
	die "syntax error on line $self.current_line: $msg";
}

string sub get_variable (string variable) {
	self.confess_at_current_line("undefined variable requested: '$variable'")
			unless contains self.variables_scope[variable];
	return self.variables_scope[variable];
}

bool sub exists_variable (string variable) {
	# my ($self, $variable) = @_;
	return contains self.variables_scope[variable];
}

string sub add_variable (string variable) {
	if (variable =~ /\A\$(\w+)\Z/s) {
		self.variables_scope[variable] = "\$var_$1";
		return self.variables_scope[variable];
	} else {
		self.confess_at_current_line("invalid variable in add_variable: '$variable'");
	}
}

string sub get_function_by_name (string name) {
	if (name =~ /\A\!(\w++)\Z/) {
		string context_identifier = match[1];
		if (contains self.contexts_by_name[context_identifier]) {
			return "context_$context_identifier";
		} else {
			self.confess_at_current_line("undefined context requested: '$context_identifier'");
		}

	} elsif (name =~ /\A\&(\w++)\Z/) {
		return "$1";

	} else {
		self.confess_at_current_line("unknown context type requested: '$name'");
	}
}

void sub compile_syntax_intermediate () {
	foreach (string key in self.global_variable_names) {
		string value = self.compile_syntax_token_value(self.global_variable_expressions[key]);
		self.global_variable_expressions[key] = value;
		self.variables_scope["\$$key"] = "\$var_$key";
	}

	foreach (tree token_definition in self.syntax_definition_intermediate.tokens) {
		string key = token_definition.identifier;
		string value = self.compile_syntax_token_value(token_definition.value);
		push self.token_definitions, {
			key => key,
			value => value,
		};
	}
	
	foreach (tree context in self.syntax_definition_intermediate.contexts) {
		self.code_definitions[context.identifier] = self.compile_syntax_context(context);
	}
	
	# foreach my $key (@{$self->{global_variable_names}}) {
	# 	my $value = $self->compile_syntax_token_value($self->{global_variable_expressions}{$key});
	# 	$self->{global_variable_expressions}{$key} = $value;
	# 	$self->{variables_scope}{"\$$key"} = "\$var_$key";
	# }

	# foreach my $token_definition (@{$self->{syntax_definition_intermediate}{tokens}}) {
	# 	my $key = $token_definition->{identifier};
	# 	my $value = $self->compile_syntax_token_value($token_definition->{value});
	# 	push @{$self->{token_definitions}}, {
	# 		key => $key,
	# 		value => $value,
	# 	};
	# }
	# foreach my $context (@{$self->{syntax_definition_intermediate}{contexts}}) {
	# 	$self->{code_definitions}{$context->{identifier}} = $self->compile_syntax_context($context);
	# }
}

string sub compile_syntax_token_value(tree value) {
	string switch (value.type) {
		'regex_value': {
			return "qr$value.value";
		}
		'substitution_regex_value': {
			return "sub { \$_[0] =~ ${value.value}r }";
		}
		'variable_value': {
			return self.get_variable(value.value);
		}
		'string_value': {
			return value.value;
		}
		default: {
			self.confess_at_current_line("invalid syntax token value: $value.type");
		}
	}
}

string sub compile_syntax_context (tree context) {
	# my ($self, $context_type, $context_name, $context) = @_;

	# my $is_linear_context = ($context->{block}[-1]{type} eq 'return_statement'
	# 		or $context->{block}[-1]{type} eq 'return_expression_statement');


	self.current_context = context;

	bool is_linear_context = 0;
	tree last_action;
	foreach (tree action in context.block) {
		last_action = action;
	}

	if (last_action) {
		if (last_action.type == 'return_statement') {
			is_linear_context = 1;
		} elsif (last_action.type == 'return_expression_statement') {
			is_linear_context = 1;
		}
	}

	list code = [];

	list args_list = [];
	push args_list, '$self';
	# my @args_list = ('$self');
	if (context.identifier != 'root') {
		push args_list, '$context_value';
	}
	string args_list_string = join ', ', args_list;
	push code, "my ($args_list_string) = \@_;";

	if (context.identifier == 'root') {
		if (context.context_type == 'object') {
			push code, "my \$context_value = {};";
		} elsif (context.context_type == 'list') {
			push code, "my \$context_value = [];";
		} else {
			push code, "my \$context_value;";
		}
	}

	# push code, "warn 'in context $context.identifier';\n"; # DEBUG INLINE TREE BUILDER
	if (is_linear_context) {
		push code, "my \@tokens;";
		push code, "my \$save_tokens_index = \$self->{tokens_index};";
		code = map { "\t$_" } code;

		push code, '';
		list push code, self.compile_syntax_action(0, context.block);
	} else {
		push code, "my \$last_loop_index = -1;";
		push code, "while (1) {";
		push code, "\t\$self->confess_at_current_offset('infinite loop in context_$context.identifier')";
		push code, "\t\t\tif \$last_loop_index == \$self->{tokens_index};";
		push code, "\t\$last_loop_index = \$self->{tokens_index};";
		# push code, "while (\$self->{tokens_index} < \@{\$self->{tokens}}) {";

		push code, "\tmy \@tokens;";
		push code, "my \$save_tokens_index = \$self->{tokens_index};";
		push code, '';
		list push code, self.compile_syntax_action(0, context.block);
		push code, "}";

		push code, "return \$context_value;";

		code = map { "\t$_" } code;
	}

	list all_code = [];
	push all_code, "sub context_$context.identifier {";
	list push all_code, code;
	push all_code, "}";

	return join '', map { "$_\n" } all_code;
}

string sub compile_syntax_condition (tree condition, int offset) {
	# my ($self, $context_type, $condition, $offset) = @_;
	int tokens_array_offset = offset;
	tokens_array_offset += self.tokens_scope_count;

	string token_condition_string;

	string switch (condition.type) {
		'optional_loop_matchgroup': {
			list compiled_conditions = [];

			int match_length = self.get_match_list_match_length(condition.match_list);
			push compiled_conditions, "((\$self->{tokens_index} = \$loop_tokens_index) + $match_length <= \@{\$self->{tokens}})";
			list push compiled_conditions, self.compile_syntax_match_list_specific(condition.match_list, tokens_array_offset);

			string main_condition = join ' and ', compiled_conditions;
			return "(do { my \$loop_tokens_index = \$self->{tokens_index}; while ($main_condition)
								{ \$loop_tokens_index = \$self->{tokens_index}; }
								\$self->{tokens_index} = \$loop_tokens_index; 1; })";
		}
		'function_match': {
			string function = self.get_function_by_name(condition.function);
			if (contains condition.argument) {
				string expression_code = self.compile_syntax_spawn_expression(condition.argument);
				string token_expression = "\$self->$function(\$self->{tokens_index}, $expression_code)";
				string token_memory_expression = "(\$tokens[$tokens_array_offset] = $token_expression)";
				token_condition_string = token_memory_expression;
			} else {
				string token_expression = "\$self->$function(\$self->{tokens_index})";
				string token_memory_expression = "(\$tokens[$tokens_array_offset] = $token_expression)";
				token_condition_string = token_memory_expression;
			}
		}
		'context_match': {
			string context = self.get_function_by_name(condition.identifier);
			if (contains condition.argument) {
				string expression_code = self.compile_syntax_spawn_expression(condition.argument);
				string token_expression = "\$self->$context($expression_code)";
				string token_memory_expression = "(\$tokens[$tokens_array_offset] = $token_expression)";
				token_condition_string = token_memory_expression;
			} else {
				string token_expression = "\$self->$context";
				string token_memory_expression = "(\$tokens[$tokens_array_offset] = $token_expression)";
				token_condition_string = token_memory_expression;
			}
		}
		'variable_match': {
			if (condition.variable =~ /\A\$(\w++)\Z/s) {
				string variable = self.get_variable(match[1]);
				string token_expression = "\$self->{tokens}[\$self->{tokens_index}++]";
				string token_memory_expression = "(\$tokens[$tokens_array_offset] = $token_expression)";
				token_condition_string = "$token_memory_expression\->[1] =~ /\\A($variable)\\Z/";
			} else {
				self.confess_at_current_line("invalid variable condition value: $condition.variable");
			}
		}
		'regex_match': {
			if (condition.regex =~ /\A\/(.*)\/([msixpodualn]*)\Z/s) {
				string token_expression = "\$self->{tokens}[\$self->{tokens_index}++]";
				string token_memory_expression = "(\$tokens[$tokens_array_offset] = $token_expression)";
				token_condition_string = "$token_memory_expression\->[1] =~ /\\A($1)\\Z/$2";
			} else {
				self.confess_at_current_line("invalid regex condition value: $condition.regex");
			}
		}
		'string_match': {
			string token_expression = "\$self->{tokens}[\$self->{tokens_index}++]";
			string token_memory_expression = "(\$tokens[$tokens_array_offset] = $token_expression)";
			token_condition_string = "$token_memory_expression\->[1] eq $condition.string";
		}
		'token_type_match': {
			string token_expression = "\$self->{tokens}[\$self->{tokens_index}++]";
			string token_memory_expression = "(\$tokens[$tokens_array_offset] = $token_expression)";
			token_condition_string = "$token_memory_expression\->[0] eq '$condition.value'";
		}
		'assignment_nonmatch': {
			token_condition_string = "1";
		}
		'death_match': {
			string expression = self.compile_syntax_spawn_expression(condition.argument);
			token_condition_string = "\$self->confess_at_current_offset($expression)";
		}
		'return_match': {
			token_condition_string = "(return \$context_value)";
		}
		default: {
			self.confess_at_current_line("invalid syntax condition '$condition.type'");
		}
	}

	if (contains condition.assign_variable) {
		string variable;
		if (self.exists_variable(condition.assign_variable)) {
			variable = self.get_variable(condition.assign_variable);
		} else {
			variable = self.add_variable(condition.assign_variable);
			variable = "my $variable";
		}

		string value_expression;
		if (condition.type == 'function_match') {
			value_expression = "\$tokens[$tokens_array_offset]";
		} elsif (condition.type == 'context_match') {
			value_expression = "\$tokens[$tokens_array_offset]";
		} elsif (condition.type == 'assignment_nonmatch') {
			value_expression = self.compile_syntax_spawn_expression(condition.expression);
		} else {
			value_expression = "\$tokens[$tokens_array_offset][1]";
		}
		token_condition_string = "($token_condition_string and (($variable = $value_expression) or do { 1 }))";
	}

	if (contains condition.assign_object_value) {
		string variable = condition.assign_object_value;
		string value_expression;
		if (condition.type == 'function_match') {
			value_expression = "\$tokens[$tokens_array_offset]";
		} elsif (condition.type == 'context_match') {
			value_expression = "\$tokens[$tokens_array_offset]";
		} elsif (condition.type == 'assignment_nonmatch') {
			value_expression = self.compile_syntax_spawn_expression(condition.expression);
		} else {
			value_expression = "\$tokens[$tokens_array_offset][1]";
		}
		token_condition_string = "($token_condition_string and do { \$context_value->{$variable} = $value_expression; 1 })";
	}

	if (contains condition.assign_object_expression_value) {
		string key_expression = self.compile_syntax_spawn_expression(condition.assign_object_expression_value);
		string value_expression;
		if (condition.type == 'function_match') {
			value_expression = "\$tokens[$tokens_array_offset]";
		} elsif (condition.type == 'context_match') {
			value_expression = "\$tokens[$tokens_array_offset]";
		} elsif (condition.type == 'assignment_nonmatch') {
			value_expression = self.compile_syntax_spawn_expression(condition.expression);
		} else {
			value_expression = "\$tokens[$tokens_array_offset][1]";
		}
		token_condition_string = "($token_condition_string and do { \$context_value->{$key_expression} = $value_expression; 1 })";
	}

	if (contains condition.assign_list_value) {
		string value_expression;
		if (condition.type == 'function_match') {
			value_expression = "\$tokens[$tokens_array_offset]";
		} elsif (condition.type == 'context_match') {
			value_expression = "\$tokens[$tokens_array_offset]";
		} else {
			value_expression = "\$tokens[$tokens_array_offset][1]";
		}
		token_condition_string = "($token_condition_string and do { push \@\$context_value, $value_expression; 1 })";
	}

	if (contains condition.assign_object_type) {
		string type_value = condition.assign_object_type;
		token_condition_string = "($token_condition_string and \$context_value->{type} = '$type_value')";
	}

	return token_condition_string;
}

string sub compile_syntax_look_ahead_condition (tree condition, int offset) {
	# my ($self, $context_type, $condition, $offset) = @_;
	string switch (condition.type) {
		'optional_loop_matchgroup': {
			list compiled_conditions = [];

			int match_length = self.get_match_list_match_length(condition.match_list);
			push compiled_conditions, "((\$self->{tokens_index} = \$loop_tokens_index) + $match_length <= \@{\$self->{tokens}})";
			list push compiled_conditions, self.compile_syntax_match_list_specific(condition.match_list, offset);

			string main_condition = join ' and ', compiled_conditions;
			return "(do { my \$loop_tokens_index = \$self->{tokens_index}; while ($main_condition)
								{ \$loop_tokens_index = \$self->{tokens_index}; }
								\$self->{tokens_index} = \$loop_tokens_index; 1; })";
		}
		'function_match': {
			string function = self.get_function_by_name(condition.function);
			if (contains condition.argument) {
				string expression_code = self.compile_syntax_spawn_expression(condition.argument);
				string token_expression = "\$self->$function(\$self->{tokens_index} + $offset, $expression_code)";
				return token_expression;
			} else {
				string token_expression = "\$self->$function(\$self->{tokens_index} + $offset)";
				return token_expression;
			}
		}
		'context_match': {
			die "context matches are not allowed in look ahead (for now)";
		}
		'variable_match': {
			if (condition.variable =~ /\A\$(\w++)\Z/s) {
				string variable = self.get_variable(match[1]);
				string token_expression = "\$self->{tokens}[\$self->{tokens_index} + $offset]";
				return "$token_expression\->[1] =~ /\\A($variable)\\Z/";
			} else {
				self.confess_at_current_line("invalid variable condition value: $condition.variable");
			}
		}
		'regex_match': {
			if (condition.regex =~ /\A\/(.*)\/([msixpodualn]*)\Z/s) {
				string token_expression = "\$self->{tokens}[\$self->{tokens_index} + $offset]";
				return "$token_expression\->[1] =~ /\\A($1)\\Z/$2";
			} else {
				self.confess_at_current_line("invalid regex condition value: $condition.regex");
			}
		}
		'string_match': {
			string token_expression = "\$self->{tokens}[\$self->{tokens_index} + $offset]";
			return "$token_expression\->[1] eq $condition.string";
		}
		'token_type_match': {
			string token_expression = "\$self->{tokens}[\$self->{tokens_index} + $offset]";
			return "$token_expression\->[0] eq '$condition.value'";
		}
		'death_match': {
			string expression = self.compile_syntax_spawn_expression(condition.argument);
			return "\$self->confess_at_current_offset($expression)";
		}
		'return_match': {
			return "(return \$context_value)";
		}
		default: {
			self.confess_at_current_line("invalid syntax condition '$condition.type'");
		}
	}
}

string sub compile_syntax_match_list (list match_list) {
	return join " \n\t\t\t\tor ", map { "($_)" } map { self.compile_syntax_match_list_branch(_) } match_list;
}

list sub compile_syntax_match_list_specific (list match_list, int i) {
	list compiled_conditions = [];

	foreach (tree condition in match_list) {
		push compiled_conditions, self.compile_syntax_condition(condition, i);
		i += 1;
	}

	return compiled_conditions;
}

string sub compile_syntax_match_list_branch (tree match_list_branches) {

	# list conditions = [];
	# list push conditions, match_list.match_conditions;
	# list push conditions, match_list.look_ahead_conditons;

	list compiled_conditions = [];
	# push compiled_conditions, '$self->more_tokens';

	int match_length = self.get_match_list_match_length(match_list_branches.match_conditions);
	match_length += self.get_match_list_match_length(match_list_branches.look_ahead_conditons);
	# int match_length = list length match_list_branches.match_conditions;
	# match_length += list length match_list_branches.look_ahead_conditons;
	# push compiled_conditions, "((\$self->{tokens_index} = \$self->{save_tokens_index}) or 1)";
	# push compiled_conditions, "((\$self->{tokens_index} = \$self->{save_tokens_index}) + $match_length <= \@{\$self->{tokens}})";
	push compiled_conditions, "((\$self->{tokens_index} = \$save_tokens_index) + $match_length <= \@{\$self->{tokens}})";
	# push compiled_conditions, "\$self->{tokens_index} + $match_length <= \@{\$self->{tokens}}";

	# int i = 0;
	list push compiled_conditions, self.compile_syntax_match_list_specific(match_list_branches.match_conditions, 0);
	# foreach (tree condition in match_list_branches.match_conditions) {
	# 	push compiled_conditions, self.compile_syntax_condition(condition, i);
	# 	i += 1;
	# }
	int i = 0;
	foreach (tree condition in match_list_branches.look_ahead_conditons) {
		push compiled_conditions, self.compile_syntax_look_ahead_condition(condition, i);
		i += 1;
	}

	int offset = self.get_match_list_match_length(match_list_branches.match_conditions);

	int count = list length match_list_branches.optional_match_conditions;
	if (count > 0) {
		push compiled_conditions,
				self.compile_syntax_match_list_optional_branch(match_list_branches.optional_match_conditions, offset);
	}

	return join ' and ', compiled_conditions;
}

string sub compile_syntax_match_list_optional_branch (list optional_match_list, int i) {
	list compiled_conditions = [];

	int match_length = list length optional_match_list;
	push compiled_conditions, "((\$self->{tokens_index} = \$save_tokens_index) + $match_length <= \@{\$self->{tokens}})";

	list push compiled_conditions, self.compile_syntax_match_list_specific(optional_match_list, i);
	# foreach (tree condition in optional_match_list) {
	# 	push compiled_conditions, self.compile_syntax_condition(condition, i);
	# 	i += 1;
	# }
	string main_condition = join ' and ', compiled_conditions;
	return "(do { \$save_tokens_index = \$self->{tokens_index}; 1 } and ($main_condition)
						or do { \$self->{tokens_index} = \$save_tokens_index ; 1 })";
}

int sub get_syntax_match_list_tokens_eaten (list match_list) {
	int i = 0;
	foreach (list branch in match_list) {
		foreach (tree condition in branch.match_conditions) {
			if (condition.type == 'optional_loop_matchgroup') {
			} elsif (condition.type == 'assignment_nonmatch') {
			} elsif (condition.type == 'death_match') {
			} elsif (condition.type == 'return_match') {
			} else {
				i += 1;
			}
		}
		# i += list length branch.match_conditions;
	}
	return i;
	# return list length match_list.match_conditions;
}

int sub get_match_list_match_length (list match_list) {
	int i = 0;
	foreach (tree condition in match_list) {
		if (condition.type == 'optional_loop_matchgroup') {
		} elsif (condition.type == 'assignment_nonmatch') {
		} elsif (condition.type == 'death_match') {
		} elsif (condition.type == 'return_match') {
		} else {
			i += 1;
		}
	}
	return i;
	# return list length match_list.match_conditions;
}

int sub get_syntax_match_list_tokens_list (tree match_list) {
	int token_count = list length match_list.match_conditions;
	int i = 0;
	list tokens_list = [];
	while (i < token_count) {
		push tokens_list, "\$token$i";
		i += 1;
	}
	return join ', ', tokens_list;
}

string sub syntax_match_list_as_string (list match_list) {
	return join ' or ', map { self.syntax_match_list_branch_as_string(_) } match_list;
}

string sub syntax_match_list_branch_as_string (tree match_list) {
	string conditions_string = join ', ', map { self.syntax_condition_as_string(_) } match_list.match_conditions;

	if (0 < list length match_list.look_ahead_conditons) {
		string look_ahead_string = join ', ', map { self.syntax_condition_as_string(_) } match_list.look_ahead_conditons;
		if (0 < length conditions_string) {
			conditions_string = "$conditions_string, (look-ahead: $look_ahead_string)";
		} else {
			conditions_string = "(look-ahead: $look_ahead_string)";
		}
	}

	conditions_string = conditions_string =~ s/([\\'])/\\$1/g;

	return conditions_string;
}

string sub syntax_condition_as_string (tree condition) {
	string switch (condition.type) {
		'optional_loop_matchgroup': {
			return join ', ', map { self.syntax_condition_as_string(_) } condition.match_list;
		}
		'function_match': {
			return "$condition.function";
		}
		'context_match': {
			return "$condition.identifier";
		}
		'variable_match': {
			return self.get_variable(condition.variable);
		}
		'regex_match': {
			return "$condition.regex";
		}
		'string_match': {
			return "$condition.string";
		}
		'token_type_match': {
			return "$condition.value token";
		}
		'death_match': {
			return "";
		}
		'return_match': {
			return "";
		}
		'assignment_nonmatch': {
			return "";
		}
		default: {
			self.confess_at_current_line("invalid syntax condition '$condition.type'");
		}
	}
}

list sub compile_syntax_action (tree match_list, list actions_list) {
	# my ($self, $context_type, $condition, $actions_list) = @_;

	list code = [];

	# create a new variable scope
	tree previous_variables_scope = self.variables_scope;
	self.variables_scope = clone previous_variables_scope;
	int previous_tokens_scope_count = self.tokens_scope_count;

	if (match_list) {
		int count = self.get_syntax_match_list_tokens_eaten(match_list);
		if (count > 0) {
			# string tokens_list_string = self.get_syntax_match_list_tokens_list(match_list);
			# push code, "my \@tokens = (\@tokens, $tokens_list_string);";
			# push code, "my \@tokens = (\@tokens, \$self->step_tokens($count));";
			# push code, "\$self->{tokens_index} += $count;";
			# push code, "\$self->{save_tokens_index} = \$self->{tokens_index};";
			push code, "\$save_tokens_index = \$self->{tokens_index};";
			# push code, "\$self->{save_tokens_index} = \$self->{tokens_index};";
			self.tokens_scope_count += count;
		}
	}
	
	foreach (tree action in actions_list) {
		self.current_line = action.line_number;

		string switch (action.type) {
			'push_statement': {
				string expression = self.compile_syntax_spawn_expression(action.expression);
				if (self.current_context.context_type == 'list') {
					push code, "push \@\$context_value, $expression;";
				} else {
					self.confess_at_current_line("use of push in $self.current_context.type");
				}
			}
			'assign_item_statement': {
				string expression = self.compile_syntax_spawn_expression(action.expression);
				if (self.exists_variable(action.variable)) {
					string variable = self.get_variable(action.variable);
					push code, "$variable = $expression;";
				} else {
					string variable = self.add_variable(action.variable);
					push code, "my $variable = $expression;";
				}
			}
			'assign_field_statement': {
				string key = self.compile_syntax_spawn_expression(action.key);
				string expression = self.compile_syntax_spawn_expression(action.expression);

				string variable = self.get_variable(action.variable);
				push code, "$variable\->{$key} = $expression;";
			}
			'assign_array_field_statement': {
				string key = self.compile_syntax_spawn_expression(action.key);
				string expression = self.compile_syntax_spawn_expression(action.expression);

				string variable = self.get_variable(action.variable);
				push code, "push \@{$variable\->{$key}}, $expression;";
			}
			'assign_object_field_statement': {
				string key = self.compile_syntax_spawn_expression(action.key);
				string subkey = self.compile_syntax_spawn_expression(action.subkey);
				string expression = self.compile_syntax_spawn_expression(action.expression);

				string variable = self.get_variable(action.variable);
				push code, "$variable\->{$key}{$subkey} = $expression;";
			}
			'return_statement': {
				push code, "return \$context_value;";
				unless (self.context_default_case) {
					self.context_default_case = [ { type => 'die_statement',
						expression => { type => 'string', string => "'unexpected token'" } } ];
				}
			}
			'return_expression_statement': {
				string expression = self.compile_syntax_spawn_expression(action.expression);
				push code, "return $expression;";

				unless (self.context_default_case) {
					self.context_default_case = [ { type => 'die_statement',
						expression => { type => 'string', string => "'unexpected token'" } } ];
				}
			}
			'match_statement': {
				string death_expression;
				if (action.death_expression) {
					death_expression = self.compile_syntax_spawn_expression(action.death_expression);
				} else {
					string match_description = self.syntax_match_list_as_string(action.match_list);
					death_expression = "'expected $match_description'";
				}

				string match_expression = self.compile_syntax_match_list(action.match_list);

				push code, "\$save_tokens_index = \$self->{tokens_index};";
				push code, "\$self->confess_at_offset($death_expression, \$save_tokens_index)";
				push code, "\tunless $match_expression;";

				int count = self.get_syntax_match_list_tokens_eaten(action.match_list);
				if (count > 0) {
					# string tokens_list_string = self.get_syntax_match_list_tokens_list(action.match_list);
					# push code, "my \@tokens = (\@tokens, $tokens_list_string);";
					# push code, "\@tokens = (\@tokens, \$self->step_tokens($count));";
					# push code, "\$self->{tokens_index} += $count;";
					# push code, "\$self->{save_tokens_index} = \$self->{tokens_index};";
					push code, "\$save_tokens_index = \$self->{tokens_index};";
					self.tokens_scope_count += count;
				}
			}
			'if_statement': {
				string condition_code = self.compile_syntax_match_list(action.match_list);
				list action_code = self.compile_syntax_action(action.match_list, action.block);

				push code, "\$save_tokens_index = \$self->{tokens_index};";
				push code, "if ($condition_code) {";
				push code, "\t\$save_tokens_index = \$self->{tokens_index};";
				list push code, action_code;
				push code, "\t\$save_tokens_index = \$self->{tokens_index};";

				tree branch = action;
				while (contains branch.branch) {
					branch = branch.branch;
					if (branch.type == 'elsif_statement') {
						string condition_code = self.compile_syntax_match_list(branch.match_list);
						list action_code = self.compile_syntax_action(branch.match_list, branch.block);

						push code, "} elsif ($condition_code) {";
						push code, "\t\$save_tokens_index = \$self->{tokens_index};";
						list push code, action_code;
						push code, "\t\$save_tokens_index = \$self->{tokens_index};";
					} else {
						list action_code = self.compile_syntax_action(branch.match_list, branch.block);

						push code, "} else {";
						push code, "\t\$self->{tokens_index} = \$save_tokens_index;";
						# push code, "\t\$self->{tokens_index} = \$self->{save_tokens_index};";
						list push code, action_code;
						push code, "\t\$save_tokens_index = \$self->{tokens_index};";
					}
				}
				push code, "}";
				push code, "\$self->{tokens_index} = \$save_tokens_index;";
				# push code, "\$self->{tokens_index} = \$self->{save_tokens_index};";
			}
			'switch_statement': {
				int first = 1;
				foreach (tree case in action.switch_cases) {
					self.current_line = case.line_number;
					if (case.type == 'match_case') {
						string condition_code = self.compile_syntax_match_list(case.match_list);
						list action_code = self.compile_syntax_action(case.match_list, case.block);

						if (first) {
							push code, "\$save_tokens_index = \$self->{tokens_index};";
							push code, "if ($condition_code) {";
							push code, "\t\$save_tokens_index = \$self->{tokens_index};";
							list push code, action_code;
							push code, "\t\$save_tokens_index = \$self->{tokens_index};";
							first = 0;
						} else {
							push code, "} elsif ($condition_code) {";
							push code, "\t\$save_tokens_index = \$self->{tokens_index};";
							list push code, action_code;
							push code, "\t\$save_tokens_index = \$self->{tokens_index};";
						}
					} elsif (case.type == 'default_case') {
						list action_code = self.compile_syntax_action(0, case.block);
						push code, "} else {";
						push code, "\t\$self->{tokens_index} = \$save_tokens_index;";
						# push code, "\t\$self->{tokens_index} = \$self->{save_tokens_index};";
						list push code, action_code;
						push code, "\t\$save_tokens_index = \$self->{tokens_index};";
					} else {
						self.confess_at_current_line("invalid switch case type: $case.type");
					}
				}
				push code, "}" unless first;
				# this is necessary if we have a basic if statement, and some tokens are advanced, but not all
				push code, "\$self->{tokens_index} = \$save_tokens_index;";
				# push code, "\$self->{tokens_index} = \$self->{save_tokens_index};";
			}
			'while_statement': {
				string condition_code = self.compile_syntax_match_list(action.match_list);
				list action_code = self.compile_syntax_action(action.match_list, action.block);

				push code, "\$save_tokens_index = \$self->{tokens_index};";
				push code, "while ($condition_code) {";
				push code, "\t\$save_tokens_index = \$self->{tokens_index};";
				list push code, action_code;
				push code, "\t\$save_tokens_index = \$self->{tokens_index};";
				push code, "}";
				push code, "\$self->{tokens_index} = \$save_tokens_index;";
			}
			'warn_statement': {
				string expression = self.compile_syntax_spawn_expression(action.expression);
				push code, "warn ($expression);";
			}
			'die_statement': {
				string expression = self.compile_syntax_spawn_expression(action.expression);
				push code, "\$self->confess_at_current_offset($expression);";
			}
			default: {
				die "undefined action '$action.type'";
			}
		}
	}

	# unscope
	self.variables_scope = previous_variables_scope;
	self.tokens_scope_count = previous_tokens_scope_count;

	return map { "\t$_" } code;
}

string sub compile_syntax_spawn_expression (tree expression) {
	# my ($self, $context_type, $expression) = @_;

	# say "debug:", Dumper $expression;
	string switch (expression.type) {
		'access': {
			string left = self.compile_syntax_spawn_expression(expression.left_expression);
			string right = self.compile_syntax_spawn_expression(expression.right_expression);
			return "${left}->{$right}";
		}
		'undef': {
			return 'undef';
		}
		'get_raw_token': {
			if (expression.token =~ /\A\$(\d+)\Z/s) {
				return "\$tokens[$1]";
			} else {
				self.confess_at_current_line("invalid spawn expression token: '$expression.token'");
			}
		}
		'get_token_type': {
			if (expression.token =~ /\A\$(\d+)\Z/s) {
				return "\$tokens[$1][0]";
			} else {
				self.confess_at_current_line("invalid spawn expression token: '$expression.token'");
			}
		}
		'get_token_text': {
			if (expression.token =~ /\A\$(\d+)\Z/s) {
				return "\$tokens[$1][1]";
			} else {
				self.confess_at_current_line("invalid spawn expression token: '$expression.token'");
			}
		}
		'get_token_line_number': {
			if (expression.token =~ /\A\$(\d+)\Z/s) {
				return "\$tokens[$1][2]";
			} else {
				self.confess_at_current_line("invalid spawn expression token: '$expression.token'");
			}
		}
		'get_token_line_offset': {
			if (expression.token =~ /\A\$(\d+)\Z/s) {
				return "\$tokens[$1][3]";
			} else {
				self.confess_at_current_line("invalid spawn expression token: '$expression.token'");
			}
		}
		'get_context': {
			return "\$context_value";
		}
		'pop_list': {
			if (self.current_context.context_type == 'list_context') {
				return "pop \@\$context_value";
			} else {
				self.confess_at_current_line("use of pop in $self.current_context.type");
			}
		}
		'call_context': {
			string context = self.get_function_by_name(expression.context);
			if (contains expression.argument) {
				string expression_code = self.compile_syntax_spawn_expression(expression.argument);
				return "\$self->$context($expression_code)";
			} else {
				return "\$self->$context";
			}
		}
		'call_function': {
			string function = self.get_function_by_name(expression.function);
			if (contains expression.argument) {
				string expression_code = self.compile_syntax_spawn_expression(expression.argument);
				return "\$self->$function($expression_code)";
			} else {
				return "\$self->$function";
			}
		}
		'call_variable': {
			string variable = self.get_variable(expression.variable);
			string expression_code = self.compile_syntax_spawn_expression(expression.argument);
			return "$variable\->($expression_code)";
		}
		'variable_value': {
			string variable = self.get_variable(expression.variable);
			return "$variable";
		}
		'call_substitution': {
			string expression_code = self.compile_syntax_spawn_expression(expression.argument);
			return "$expression_code =~ ${expression.regex}r";
		}
		'string': {
			return "$expression.string";
		}
		'bareword_string': {
			return "'$expression.value'";
		}
		'bareword': {
			return "$expression.value";
		}
		'empty_list': {
			return '[]';
		}
		'empty_hash': {
			return '{}';
		}
		'list_constructor': {
			string code = "[ ";
			foreach (tree field in expression.arguments) {
				string field_expression_code = self.compile_syntax_spawn_expression(field);
				code += "$field_expression_code, ";
			}
			code += "]";
			return code;
		}
		'hash_constructor': {
			string code = "{ ";
			list arguments = expression.arguments;
			list items = clone arguments;
			while (0 < length items) {
				tree field = shift items;
				tree value = shift items;
				string field_expression_code = self.compile_syntax_spawn_expression(field);
				string value_expression_code = self.compile_syntax_spawn_expression(value);
				code += "$field_expression_code => $value_expression_code, ";
			}
			code += "}";
			return code;
		}
		default: {
			self.confess_at_current_line("invalid spawn expression: '$expression.type'");
		}
	}
}

string sub get_standalone_functionality() {
	return '

sub new {
	my ($class, %opts) = @_;
	my $self = bless {}, $class;

	$self->{filepath} = Sugar::IO::File->new($opts{filepath}) if defined $opts{filepath};
	$self->{text} = $opts{text} if defined $opts{text};

	$self->{token_regexes} = $tokens // die "token_regexes argument required for Sugar::Lang::Tokenizer";
	$self->{ignored_tokens} = $ignored_tokens;

	$self->compile_tokenizer_regex;

	return $self
}

sub parse {
	my ($self) = @_;
	return $self->parse_from_context("context_root");
}

sub parse_from_context {
	my ($self, $context) = @_;
	$self->parse_tokens;

	$self->{syntax_tree} = $self->$context($self->{syntax_tree});
	$self->confess_at_current_offset("more tokens after parsing complete") if $self->{tokens_index} < @{$self->{tokens}};

	return $self->{syntax_tree};
}

sub compile_tokenizer_regex {
	my ($self) = @_;
	use re \'eval\';
	my $token_pieces = join \'|\',
			map "($self->{token_regexes}[$_*2+1])(?{\'$self->{token_regexes}[$_*2]\'})",
				0 .. $#{$self->{token_regexes}} / 2;
	$self->{tokenizer_regex} = qr/$token_pieces/so;

# 	# optimized selector for token names, because %+ is slow
# 	my @index_names = map $self->{token_regexes}[$_*2], 0 .. $#{$self->{token_regexes}} / 2;
# 	my @index_variables = map "\$$_", 1 .. @index_names;
# 	my $index_selectors = join "\n\tels",
# 			map "if (defined $index_variables[$_]) { return \'$index_names[$_]\', $index_variables[$_]; }",
# 			0 .. $#index_names;

# 	$self->{token_selector_callback} = eval "
# sub {
# 	$index_selectors
# }
# ";
}

sub parse_tokens {
	my ($self) = @_;

	my $text;
	$text = $self->{filepath}->read if defined $self->{filepath};
	$text = $self->{text} unless defined $text;

	die "no text or filepath specified before parsing" unless defined $text;

	return $self->parse_tokens_in_text($text)
}


sub parse_tokens_in_text {
	my ($self, $text) = @_;
	$self->{text} = $text;
	
	my @tokens;

	my $line_number = 1;
	my $offset = 0;

	# study $text;
	while ($text =~ /\G$self->{tokenizer_regex}/gco) {
		# despite the absurdity of this solution, this is still faster than loading %+
		# my ($token_type, $token_text) = each %+;
		# my ($token_type, $token_text) = $self->{token_selector_callback}->();
		my ($token_type, $token_text) = ($^R, $^N);

		push @tokens, [ $token_type => $token_text, $line_number, $offset ];
		$offset = pos $text;
		# amazingly, this is faster than a regex or an index count
		# must be because perl optimizes out the string modification, and just performs a count
		$line_number += $token_text =~ y/\n//;
	}

	die "parsing error on line $line_number:\nHERE ---->" . substr ($text, pos $text // 0, 200) . "\n\n\n"
			if not defined pos $text or pos $text != length $text;

	if (defined $self->{ignored_tokens}) {
		foreach my $ignored_token (@{$self->{ignored_tokens}}) {
			@tokens = grep $_->[0] ne $ignored_token, @tokens;
		}
	}

	# @tokens = $self->filter_tokens(@tokens);

	$self->{tokens} = \@tokens;
	$self->{tokens_index} = 0;
	$self->{save_tokens_index} = 0;

	return $self->{tokens}
}

sub confess_at_current_offset {
	my ($self, $msg) = @_;

	my $position;
	my $next_token = \'\';
	if ($self->{tokens_index} < @{$self->{tokens}}) {
		$position = \'line \' . $self->{tokens}[$self->{tokens_index}][2];
		my ($type, $val) = @{$self->{tokens}[$self->{tokens_index}]};
		$next_token = " (next token is $type => <$val>)";
	} else {
		$position = \'end of file\';
	}

	# say $self->dump_at_current_offset;

	die "error on $position: $msg$next_token";
}
sub confess_at_offset {
	my ($self, $msg, $offset) = @_;

	my $position;
	my $next_token = \'\';
	if ($offset < @{$self->{tokens}}) {
		$position = \'line \' . $self->{tokens}[$offset][2];
		my ($type, $val) = ($self->{tokens}[$offset][0], $self->{tokens}[$offset][1]);
		$next_token = " (next token is $type => <$val>)";
	} else {
		$position = \'end of file\';
	}

	# say $self->dump_at_current_offset;

	die "error on $position: $msg$next_token";
}

';
}

void sub main () native:perl5 {{
	my ($files_list) = @_;

	# require Data::Dumper;
	require Sugar::IO::File;
	use Sugar::Lang::SugarGrammarParser;
	# use Sugar::Lang::SugarGrammarCompiler;

	my %compile_args;
	foreach my $file (@$files_list) {
		if ($file eq '--standalone') {
			$compile_args{compile_standalone} = 1;
			next;
		}

		my $parser = Sugar::Lang::SugarGrammarParser->new;
		$parser->{filepath} = Sugar::IO::File->new($file);
		my $tree = $parser->parse;
		# say Dumper $tree;

		my $compiler = Sugar::Lang::SugarGrammarCompiler->new({syntax_definition_intermediate => $tree, %compile_args});
		$compiler->compile_syntax_intermediate;
		say $compiler->to_package;
	}
}}

}

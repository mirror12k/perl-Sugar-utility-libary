# Sugar grammar language parser
package Sugar::Lang::SugarGrammarParser

# regex definitions
code_block_regex = /\{\{.*?\}\}/s
symbol_regex = /\(|\)|\{|\}|\[|\]|->|=>|=|,|\*|:/

package_identifier_regex = /[a-zA-Z_][a-zA-Z0-9_]*+(\:\:[a-zA-Z_][a-zA-Z0-9_]*+)++/
identifier_regex = /[a-zA-Z_][a-zA-Z0-9_]*+/
string_regex = /'([^\\']|\\[\\'])*+'/s
regex_regex = /\/([^\\\/]|\\.)*+\/[msixpodualn]*+/s
substitution_regex_regex = /s\/([^\\\/]|\\.)*+\/([^\\\/]|\\.)*+\/[msixpodualngcer]*+/s
variable_regex = /\$\w++/
context_reference_regex = /!\w++/
function_reference_regex = /\&\w++/

comment_regex = /\#[^\n]*+\n/s
whitespace_regex = /\s++/s

# tokens specified to the token parser
tokens {
	code_block => $code_block_regex
	symbol => $symbol_regex
	regex => $regex_regex
	substitution_regex => $substitution_regex_regex

	package_identifier => $package_identifier_regex
	identifier => $identifier_regex
	string => $string_regex
	variable => $variable_regex
	context_reference => $context_reference_regex
	function_reference => $function_reference_regex

	comment => $comment_regex
	whitespace => $whitespace_regex
}

# tokens that will get filtered off
ignored_tokens {
	comment
	whitespace
}

# context definitions
object context root {
	switch {
		*identifier, '=' => {
			$_{global_variable_names}[] = $0
			$_{global_variable_expressions}{$0} = !def_value
		}
		'package', *package_identifier => {
			$_{package_identifier} = $1
		}
		'package', *identifier => {
			$_{package_identifier} = $1
		}
		'tokens', '{' => {
			$_{tokens} = !token_definition->[]
		}
		'ignored_tokens', '{' => {
			$_{ignored_tokens} = !ignored_tokens_list->[]
		}
		'item', 'context', *identifier => {
			$_{context_order}[] = $2
			$_{item_contexts}{$2} = !action_block
		}
		'list', 'context', *identifier => {
			$_{context_order}[] = $2
			$_{list_contexts}{$2} = !action_block
		}
		'object', 'context', *identifier => {
			$_{context_order}[] = $2
			$_{object_contexts}{$2} = !action_block
		}
		'sub', *identifier, *code_block => {
			$_{subroutine_order}[] = $1
			$_{subroutines}{$1} = $2
		}
	}
}

item context def_value {
	switch {
		*string => {
			return $0
		}
		*substitution_regex => {
			return $0
		}
		*regex => {
			return $0
		}
		*variable => {
			return $0
		}
		default {
			die 'unexpected token in def_value'
		}
	}
}

list context token_definition {
	switch {
		'}' => {
			return
		}
		*identifier, '=>' => {
			push token_definition:{
				identifier => $0
				value => !def_value
			}
		}
		default {
			die 'unexpected token in token_definition'
		}
	}
}

list context ignored_tokens_list {
	switch {
		'}' => {
			return
		}
		*identifier => {
			push $0
		}
		default {
			die 'unexpected token in ignored_tokens_list'
		}
	}
}

object context match_list_specifier {
	$_ = {
		match_conditions => []
		look_ahead_conditons => []
	}
	if '(' => {
		$_{look_ahead_conditons} = !match_conditions_list
		match ')'
	} else {
		$_{match_conditions} = !match_conditions_list
		if '(' => {
			$_{look_ahead_conditons} = !match_conditions_list
			match ')'
		}
	}
	return
}

list context match_conditions_list {
	push !match_item
	while ',' => {
		push !match_item
	}
	return
}

list context match_list_arrow {
	$_ = !match_list_specifier->$_
	match '=>'
	return
}

item context match_item {
	switch {
		*function_reference, '->' => {
			return function_match:{
				function => $0
				argument => !spawn_expression
			}
		}
		*function_reference => {
			return function_match:{ function => $0 }
		}
		*variable => {
			return variable_match:{ variable => $0 }
		}
		*regex => {
			return regex_match:{ regex => $0 }
		}
		*string => {
			return string_match:{ string => $0 }
		}
		'*', *identifier => {
			return token_type_match:{ value => $1 }
		}
		default {
			die 'expected match item'
		}
	}
}

item context action_block {
	match '{' or die '"{" expected for code block'
	$_ = !match_action->[]
	match '}' or die '"}" expected after code block'
	return
}

list context match_action {
	switch {
		*variable, '=' => {
			push assign_item_statement:{
				variable => $0
				expression => !spawn_expression
			}
		}
		*variable, '{' => {
			$key_expression = !spawn_expression
			match '}' or die '"}" expected after key expression'
			if '{' => {
				$subkey_expression = !spawn_expression
				match '}', '=' or die '"}", "=" expected after sub-key expression'
				push assign_object_field_statement:{
					variable => $0
					expression => !spawn_expression
					subkey => $subkey_expression
					key => $key_expression
				}
			} elsif '[' => {
				match ']', '=' or die '"]", "=" expected after array access expression'
				push assign_array_field_statement:{
					variable => $0
					expression => !spawn_expression
					key => $key_expression
				}
			} else {
				match '=' or die '"=" expected after key expression'
				push assign_field_statement:{
					variable => $0
					expression => !spawn_expression
					key => $key_expression
				}
			}

		}
		'push' => {
			push push_statement:{
				expression => !spawn_expression
			}
		}
		'return' => {
			if ('}') => {
				push return_statement:{}
			} else {
				push return_expression_statement:{
					expression => !spawn_expression
				}
			}
		}
		'match' => {
			# push match_statement:{
			# 	match_list => !match_list_specifier
			# }
			$statement = match_statement:{
				match_list => !match_list_specifier
			}
			if 'or', 'die' => {
				$statement{death_expression} = !spawn_expression
			}
			push $statement
		}
		'if' => {
			push !if_chain->if_statement:{
				match_list => !match_list_arrow
				block => !action_block
			}
		}
		'switch' => {
			match '{'
			push switch_statement:{
				switch_cases => !switch_blocks->[]
			}
		}
		'while' => {
			push while_statement:{
				match_list => !match_list_arrow
				block => !action_block
			}
		}
		'warn' => {
			push warn_statement:{
				expression => !spawn_expression
			}
		}
		'die' => {
			push die_statement:{
				expression => !spawn_expression
			}
		}
		# *variable, '=' => {
		# 	push variable_assignment_statement:{
		# 		variable => $0
		# 		expression => !spawn_expression
		# 	}
		# }
		default {
			return
		}
	}
}


list context switch_blocks {
	switch {
		'}' => {
			return
		}
		'default' => {
			push default_case:{
				block => !action_block
			}
			match '}'
			return
		}
		default {
			push match_case:{
				match_list => !match_list_arrow
				block => !action_block
			}
		}
	}
}



object context if_chain {
	switch {
		'elsif' => {
			$_{'branch'} = !if_chain->elsif_statement:{
				match_list => !match_list_arrow
				block => !action_block
			}
			return
		}
		'else' => {
			$_{'branch'} = else_statement:{
				block => !action_block
			}
			return
		}
		default {
			return
		}
	}
}

item context spawn_expression {
	switch {
		/\$\d++/, '{', 'line_number', '}' => {
			return get_token_line_number:{ token => $0 }
		}
		/\$\d++/, '{', 'line_offset', '}' => {
			return get_token_line_offset:{ token => $0 }
		}
		/\$\d++/ => {
			return get_token_text:{ token => $0 }
		}
		'$_' => {
			return !more_spawn_expression->get_context:{}
		}
		'pop' => {
			warn 'pop expressions are deprecated'
			return pop_list:{}
		}



		'[', ']' => {
			return empty_list:{}
		}
		'[' => {
			return list_constructor:{
				arguments => !spawn_expression_list->[]
			}
		}
		'{', '}' => {
			return empty_hash:{}
		}
		'{' => {
			return hash_constructor:{
				arguments => !spawn_expression_hash->[]
			}
		}
		*identifier, ':', '{' => {
			# translate down a typed object into a basic object constructor
			return hash_constructor:{
				arguments => !spawn_expression_hash->[
					bareword:{ value => 'type' }, bareword_string:{ value => $0 },
					bareword:{ value => 'line_number' }, get_token_line_number:{ token => '$0' },
				]
			}
		}

		'undef' => {
			return undef:{}
		}



		*context_reference, '->' => {
			return call_context:{
				context => $0
				argument => !spawn_expression
			}
		}
		*context_reference => {
			return call_context:{
				context => $0
			}
		}
		*function_reference, '->' => {
			return call_function:{
				function => $0
				argument => !spawn_expression
			}
		}
		*function_reference => {
			return call_function:{
				function => $0
			}
		}
		*substitution_regex, '->' => {
			return call_substitution:{
				regex => $0
				argument => !spawn_expression
			}
		}
		*variable, '->' => {
			return call_variable:{
				variable => $0
				argument => !spawn_expression
			}
		}
		*variable => {
			return !more_spawn_expression->variable_value:{ variable => $0 }
		}
		*string => {
			return string:{ string => $0 }
		}
		*identifier => {
			return bareword:{ value => $0 }
		}

		default {
			die 'push expression expected'
		}
	}
}

object context more_spawn_expression {
	switch {
		'{' => {
			$_ = access:{
				left_expression => $_
				right_expression => !spawn_expression
			}
			match '}'
		}
		default {
			return
		}
	}
}

list context spawn_expression_list {
	switch {
		']' => {
			return
		}
		default {
			push !spawn_expression
			if ',' => {
				# keep going
			} elsif ']' => {
				return
			} else {
				return
			}
		}
	}
}

list context spawn_expression_hash {
	switch {
		'}' => {
			return
		}
		default {
			push !spawn_expression
			match '=>'
			push !spawn_expression
		}
	}
}




sub main {{
	use Data::Dumper;
	use Sugar::IO::File;
	use Sugar::Lang::SyntaxIntermediateCompiler;

	my $parser = __PACKAGE__->new;
	foreach my $file (@_) {
		$parser->{filepath} = Sugar::IO::File->new($file);
		my $tree = $parser->parse;
		# say Dumper $tree;

		my $compiler = Sugar::Lang::SyntaxIntermediateCompiler->new(syntax_definition_intermediate => $tree);
		say $compiler->to_package;
	}
}}




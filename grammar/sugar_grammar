# Sugar grammar language parser
package Sugar::Lang::GrammarCompiler

# regex definitions
code_block_regex = /\{\{.*?\}\}/s
symbol_regex = /\{|\}|\[|\]|->|=>|=|,/

package_identifier_regex = /[a-zA-Z_][a-zA-Z0-9_]*+(\:\:[a-zA-Z_][a-zA-Z0-9_]*+)*+/
identifier_regex = /[a-zA-Z_][a-zA-Z0-9_]*+/
string_regex = /'([^\\']|\\[\\'])*+'/s
regex_regex = /\/([^\\\/]|\\.)*+\/[msixpodualn]*/s
variable_regex = /\$\w++/
context_reference_regex = /!\w++/
function_reference_regex = /\&\w++/

comment_regex = /\#[^\n]*+\n/s
whitespace_regex = /\s++/s

# tokens specified to the token parser
tokens {
	code_block => $code_block_regex
	symbol => $symbol_regex

	package_identifier => $package_identifier_regex
	identifier => $identifier_regex
	string => $string_regex
	regex => $regex_regex
	variable => $variable_regex
	context_reference => $context_reference_regex
	function_reference => $function_reference_regex

	comment => $comment_regex
	whitespace => $whitespace_regex
}

# tokens that will get filtered off
ignored_tokens {
	comment
	whitespace
}

# context definitions
object context root {
	$identifier_regex, '=' {
		$_{'variables'}{$0} = !def_value
	}
	'package', $package_identifier_regex {
		$_{'package_identifier'} = $1
	}
	'tokens', '{' {
		$_{'tokens'} = !token_definition->[]
	}
	'ignored_tokens', '{' {
		$_{'ignored_tokens'} = !ignored_tokens_list->[]
	}
	'item', 'context', $identifier_regex, '{' {
		$_{'item_contexts'}{$2} = !context_definition->[]
	}
	'list', 'context', $identifier_regex, '{' {
		$_{'list_contexts'}{$2} = !context_definition->[]
	}
	'object', 'context', $identifier_regex, '{' {
		$_{'object_contexts'}{$2} = !context_definition->[]
	}
	'sub', $identifier_regex, $code_block_regex {
		$_{'subroutines'}{$1} = $2
	}
}

item context def_value {
	$string_regex {
		$_ = $0
		return
	}
	$regex_regex {
		$_ = $0
		return
	}
	$variable_regex {
		$_ = $0
		return
	}
	default {
		die 'unexpected token in def_value'
	}
}

list context token_definition {
	'}' {
		return
	}
	$identifier_regex, '=>' {
		push $0
		push !def_value
	}
	default {
		die 'unexpected token in token_definition'
	}
}

list context ignored_tokens_list {
	'}' {
		return
	}
	$identifier_regex {
		push $0
	}
	default {
		die 'unexpected token in ignored_tokens_list'
	}
}

list context context_definition {
	'}' {
		return
	}
	'default', '{' {
		push undef
		push !match_action->[]
		match '}'
	}
	default {
		push !match_list->[]
		match '{'
		push !match_action->[]
		match '}'
	}
}

list context match_list {
	$variable_regex, ',' {
		push $0
	}
	$variable_regex {
		push $0
		return
	}
	$regex_regex, ',' {
		push $0
	}
	$regex_regex {
		push $0
		return
	}
	$string_regex, ',' {
		push $0
	}
	$string_regex {
		push $0
		return
	}
	default {
		die 'unexpected end of match list'
	}
}

list context match_action {
	'$_', '=' {
		push 'assign_item'
		push !spawn_expression
	}
	'$_', '{', $string_regex, '}', '{' {
		push 'assign_object_field'
		push {
			'type' => 'string'
			'string' => $2
		}
		push !spawn_expression
		match '}', '='
		push !spawn_expression
	}
	'$_', '{', $string_regex, '}', '[', ']', '=' {
		push 'assign_array_field'
		push {
			'type' => 'string'
			'string' => $2
		}
		push !spawn_expression
	}
	'$_', '{', $string_regex, '}', '=' {
		push 'assign_field'
		push {
			'type' => 'string'
			'string' => $2
		}
		push !spawn_expression
	}
	'push' {
		push 'push'
		push !spawn_expression
	}
	'return' {
		push 'return'
	}
	'match' {
		push 'match'
		push !match_list->[]
	}
	'if' {
		push 'if'
		push !match_list->[]
		match '{'
		push !match_action->[]
		match '}'
		$_ = !if_chain->$_
	}
	'while' {
		push 'while'
		push !match_list->[]
		match '{'
		push !match_action->[]
		match '}'
	}
	'warn' {
		push 'warn'
		push !spawn_expression
	}
	'die' {
		push 'die'
		push !spawn_expression
	}
	# '}' {
	# 	return
	# }
	default {
		return
		# die 'expected \'}\' to close match actions list'
	}
}

list context if_chain {
	'elsif' {
		push 'elsif'
		push !match_list->[]
		match '{'
		push !match_action->[]
		match '}'
	}
	'else' {
		push 'else'
		match '{'
		push !match_action->[]
		match '}'
		return
	}
	default {
		return
	}
}

item context spawn_expression {
	/\$\d++/, '{', 'line_number', '}' {
		$_ = {
			'type' => 'get_token_line_number'
			'token' => $0
		}
		return
	}
	/\$\d++/, '{', 'offset', '}' {
		$_ = {
			'type' => 'get_token_offset'
			'token' => $0
		}
		return
	}
	/\$\d++/ {
		$_ = {
			'type' => 'get_token_text'
			'token' => $0
		}
		return
	}
	'$_' {
		$_ = {
			'type' => 'get_context'
		}
		return
	}
	'pop' {
		$_ = {
			'type' => 'pop_list'
		}
		return
	}

	$context_reference_regex, '->' {
		$_ = {
			'type' => 'call_context'
			'context' => $0
			'argument' => !spawn_expression
		}
		return
	}
	$context_reference_regex {
		$_ = {
			'type' => 'call_context'
			'context' => $0
		}
		return
	}
	$function_reference_regex, '->' {
		$_ = {
			'type' => 'call_function'
			'function' => $0
			'argument' => !spawn_expression
		}
		return
	}
	$function_reference_regex {
		$_ = {
			'type' => 'call_function'
			'function' => $0
		}
		return
	}
	$string_regex {
		$_ = {
			'type' => 'string'
			'string' => $0
		}
		return
	}


	'undef' {
		$_ = {
			'type' => 'undef'
		}
		return
	}
	'[', ']' {
		$_ = {
			'type' => 'empty_list'
		}
		return
	}
	'{', '}' {
		$_ = {
			'type' => 'empty_hash'
		}
		return
	}
	'{' {
		$_ = {
			'type' => 'hash_constructor'
			'arguments' => !spawn_expression_hash->[]
		}
		return
	}

	# '$_' {
	# 	$_ = $0
	# 	return
	# }
	# 'pop' {
	# 	$_ = 'pop'
	# 	return
	# }
	# $context_reference_regex, '->' {
	# 	$_ = {
	# 		$0 => !spawn_expression
	# 	}
	# 	return
	# }
	# $context_reference_regex {
	# 	$_ = $0
	# 	return
	# }
	# $function_reference_regex, '->' {
	# 	$_ = {
	# 		$0 => !spawn_expression
	# 	}
	# 	return
	# }
	# $function_reference_regex {
	# 	$_ = $0
	# 	return
	# }
	# $string_regex {
	# 	$_ = $0
	# 	return
	# }
	# 'undef' {
	# 	$_ = undef
	# 	return
	# }
	# '[', ']' {
	# 	$_ = []
	# 	return
	# }
	# '{', '}' {
	# 	$_ = {}
	# 	return
	# }
	# '{' {
	# 	$_ = !spawn_expression_hash->[]
	# 	return
	# }
	default {
		die 'push expression expected'
	}
}

list context spawn_expression_list {
	$context_reference_regex, ']' {
		push $0
		return
	}
	default {
		die 'push expression list expected'
	}
}

list context spawn_expression_hash {
	'}' {
		return
	}
	# $variable_regex, '=>' {
	# 	push $0
	# 	push !spawn_expression
	# }
	# $string_regex, '=>' {
	# 	push $0
	# 	push !spawn_expression
	# }
	default {
		push !spawn_expression
		match '=>'
		push !spawn_expression
	}
}

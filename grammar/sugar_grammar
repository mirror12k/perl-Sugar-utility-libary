# Sugar grammar language parser
package Sugar::Lang::GrammarCompiler

# regex definitions
code_block_regex = /\{\{.*?\}\}/s
symbol_regex = /\{|\}|\[|\]|->|=>|=|,/

package_identifier_regex = /[a-zA-Z_][a-zA-Z0-9_]*+(\:\:[a-zA-Z_][a-zA-Z0-9_]*+)*+/
identifier_regex = /[a-zA-Z_][a-zA-Z0-9_]*+/
string_regex = /'([^\\']|\\[\\'])*+'/s
regex_regex = /\/([^\\\/]|\\.)*+\/[msixpodualn]*+/s
substitution_regex_regex = /s\/([^\\\/]|\\.)*+\/([^\\\/]|\\.)*+\/[msixpodualngcer]*+/s
variable_regex = /\$\w++/
context_reference_regex = /!\w++/
function_reference_regex = /\&\w++/

comment_regex = /\#[^\n]*+\n/s
whitespace_regex = /\s++/s

# tokens specified to the token parser
tokens {
	code_block => $code_block_regex
	symbol => $symbol_regex
	regex => $regex_regex
	substitution_regex => $substitution_regex_regex

	package_identifier => $package_identifier_regex
	identifier => $identifier_regex
	string => $string_regex
	variable => $variable_regex
	context_reference => $context_reference_regex
	function_reference => $function_reference_regex

	comment => $comment_regex
	whitespace => $whitespace_regex
}

# tokens that will get filtered off
ignored_tokens {
	comment
	whitespace
}

# context definitions
object context root {
	switch {
		$identifier_regex, '=' {
			$_{'variables'}[] = $0
			$_{'variables'}[] = !def_value
		}
		'package', $package_identifier_regex {
			$_{'package_identifier'} = $1
		}
		'tokens', '{' {
			$_{'tokens'} = !token_definition->[]
		}
		'ignored_tokens', '{' {
			$_{'ignored_tokens'} = !ignored_tokens_list->[]
		}
		'item', 'context', $identifier_regex {
			$_{'context_order'}[] = $2
			$_{'item_contexts'}{$2} = !action_block
		}
		'list', 'context', $identifier_regex {
			$_{'context_order'}[] = $2
			$_{'list_contexts'}{$2} = !action_block
		}
		'object', 'context', $identifier_regex {
			$_{'context_order'}[] = $2
			$_{'object_contexts'}{$2} = !action_block
		}
		'sub', $identifier_regex, $code_block_regex {
			$_{'subroutine_order'}[] = $1
			$_{'subroutines'}{$1} = $2
		}
	}
}

item context def_value {
	switch {
		$string_regex {
			$_ = $0
			return
		}
		$substitution_regex_regex {
			$_ = $0
			return
		}
		$regex_regex {
			$_ = $0
			return
		}
		$variable_regex {
			$_ = $0
			return
		}
		default {
			die 'unexpected token in def_value'
		}
	}
}

list context token_definition {
	switch {
		'}' {
			return
		}
		$identifier_regex, '=>' {
			push $0
			push !def_value
		}
		default {
			die 'unexpected token in token_definition'
		}
	}
}

list context ignored_tokens_list {
	switch {
		'}' {
			return
		}
		$identifier_regex {
			push $0
		}
		default {
			die 'unexpected token in ignored_tokens_list'
		}
	}
}

list context match_list {
	push !match_item
	while ',' {
		push !match_item
	}
	return
}

item context match_item {
	switch {
		$variable_regex {
			$_ = $0
			return
		}
		$regex_regex {
			$_ = $0
			return
		}
		$string_regex {
			$_ = $0
			return
		}
		default {
			die 'expected match item'
		}
	}
}

item context action_block {
	match '{'
	$_ = !match_action->[]
	match '}'
	return
}

list context match_action {
	switch {
		'$_', '=' {
			push {
				'type' => 'assign_item_statement'
				'line_number' => $0{line_number}
				'expression' => !spawn_expression
			}
		}
		'$_', '{' {
			push !spawn_expression
			match '}'
			if '{' {
				push !spawn_expression
				match '}', '='
				push {
					'type' => 'assign_object_field_statement'
					'line_number' => $0{line_number}
					'expression' => !spawn_expression
					'subkey' => pop
					'key' => pop
				}
			} elsif '[' {
				match ']', '='
				push {
					'type' => 'assign_array_field_statement'
					'line_number' => $0{line_number}
					'expression' => !spawn_expression
					'key' => pop
				}
			} else {
				match '='
				push {
					'type' => 'assign_field_statement'
					'line_number' => $0{line_number}
					'expression' => !spawn_expression
					'key' => pop
				}
			}

		}
		'push' {
			push {
				'type' => 'push_statement'
				'line_number' => $0{line_number}
				'expression' => !spawn_expression
			}
		}
		'return' {
			push {
				'type' => 'return_statement'
				'line_number' => $0{line_number}
			}
		}
		'match' {
			push {
				'type' => 'match_statement'
				'line_number' => $0{line_number}
				'match_list' => !match_list->[]
			}
		}
		'if' {
			push !if_chain->{
				'type' => 'if_statement'
				'line_number' => $0{line_number}
				'match_list' => !match_list->[]
				'block' => !action_block
			}
		}
		'switch' {
			match '{'
			push !if_chain->{
				'type' => 'switch_statement'
				'line_number' => $0{line_number}
				'switch_cases' => !switch_blocks->[]
			}
		}
		'while' {
			push {
				'type' => 'while_statement'
				'line_number' => $0{line_number}
				'match_list' => !match_list->[]
				'block' => !action_block
			}
		}
		'warn' {
			push {
				'type' => 'warn_statement'
				'line_number' => $0{line_number}
				'expression' => !spawn_expression
			}
		}
		'die' {
			push {
				'type' => 'die_statement'
				'line_number' => $0{line_number}
				'expression' => !spawn_expression
			}
		}
		default {
			return
		}
	}
}


list context switch_blocks {
	switch {
		'}' {
			return
		}
		'default' {
			push {
				'type' => 'default_case'
				'line_number' => $0{line_number}
				'block' => !action_block
			}
			match '}'
			return
		}
		default {
			push {
				'type' => 'match_case'
				'line_number' => $0{line_number}
				'match_list' => !match_list->[]
				'block' => !action_block
			}
		}
	}
}



object context if_chain {
	switch {
		'elsif' {
			$_{'branch'} = !if_chain->{
				'type' => 'elsif_statement'
				'line_number' => $0{line_number}
				'match_list' => !match_list->[]
				'block' => !action_block
			}
			return
		}
		'else' {
			$_{'branch'} = {
				'type' => 'else_statement'
				'line_number' => $0{line_number}
				'block' => !action_block
			}
			return
		}
		default {
			return
		}
	}
}

item context spawn_expression {
	switch {
		/\$\d++/, '{', 'line_number', '}' {
			$_ = {
				'type' => 'get_token_line_number'
				'token' => $0
			}
			return
		}
		/\$\d++/, '{', 'line_offset', '}' {
			$_ = {
				'type' => 'get_token_line_offset'
				'token' => $0
			}
			return
		}
		/\$\d++/ {
			$_ = {
				'type' => 'get_token_text'
				'token' => $0
			}
			return
		}
		'$_' {
			$_ = !more_spawn_expression->{
				'type' => 'get_context'
			}
			return
		}
		'pop' {
			$_ = {
				'type' => 'pop_list'
			}
			return
		}

		$context_reference_regex, '->' {
			$_ = {
				'type' => 'call_context'
				'context' => $0
				'argument' => !spawn_expression
			}
			return
		}
		$context_reference_regex {
			$_ = {
				'type' => 'call_context'
				'context' => $0
			}
			return
		}
		$function_reference_regex, '->' {
			$_ = {
				'type' => 'call_function'
				'function' => $0
				'argument' => !spawn_expression
			}
			return
		}
		$function_reference_regex {
			$_ = {
				'type' => 'call_function'
				'function' => $0
			}
			return
		}
		$substitution_regex_regex, '->' {
			$_ = {
				'type' => 'call_substitution'
				'regex' => $0
				'argument' => !spawn_expression
			}
			return
		}
		$variable_regex, '->' {
			$_ = {
				'type' => 'call_variable'
				'variable' => $0
				'argument' => !spawn_expression
			}
			return
		}
		$variable_regex {
			$_ = {
				'type' => 'call_variable'
				'variable' => $0
			}
			return
		}
		$string_regex {
			$_ = {
				'type' => 'string'
				'string' => $0
			}
			return
		}


		'undef' {
			$_ = {
				'type' => 'undef'
			}
			return
		}
		'[', ']' {
			$_ = {
				'type' => 'empty_list'
			}
			return
		}
		'{', '}' {
			$_ = {
				'type' => 'empty_hash'
			}
			return
		}
		'{' {
			$_ = {
				'type' => 'hash_constructor'
				'arguments' => !spawn_expression_hash->[]
			}
			return
		}
		default {
			die 'push expression expected'
		}
	}
}

object context more_spawn_expression {
	switch {
		'{' {
			$_ = {
				'type' => 'access'
				'left_expression' => $_
				'right_expression' => !spawn_expression
			}
			match '}'
		}
		default {
			return
		}
	}
}

list context spawn_expression_hash {
	switch {
		'}' {
			return
		}
		default {
			push !spawn_expression
			match '=>'
			push !spawn_expression
		}
	}
}




sub main {{
	use Data::Dumper;
	use Sugar::IO::File;
	use Sugar::Lang::SyntaxIntermediateCompiler;

	my $parser = __PACKAGE__->new;
	foreach my $file (@_) {
		$parser->{filepath} = Sugar::IO::File->new($file);
		my $tree = $parser->parse;
		# say Dumper $tree;

		my $compiler = Sugar::Lang::SyntaxIntermediateCompiler->new(syntax_definition_intermediate => $tree);
		say $compiler->to_package;
	}
}}




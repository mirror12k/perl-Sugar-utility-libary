# Sugar grammar language parser
package Sugar::Lang::GrammarCompiler

# regex definitions
symbol_regex = /\{|\}|\[|\]|->|=>|=|,/

package_identifier_regex = /[a-zA-Z_][a-zA-Z0-9_]*+(\:\:[a-zA-Z_][a-zA-Z0-9_]*+)++/
identifier_regex = /[a-zA-Z_][a-zA-Z0-9_]*+/
string_regex = /'([^\\']|\\[\\'])*+'/s
regex_regex = /\/([^\\\/]|\\.)*+\/[msixpodualn]*/s
variable_regex = /\$\w++/
context_reference_regex = /!\w++/
function_reference_regex = /\&\w++/

comment_regex = /\#[^\n]*+\n/s
whitespace_regex = /\s++/s

# tokens specified to the token parser
tokens {
	symbol => $symbol_regex

	package_identifier => $package_identifier_regex
	identifier => $identifier_regex
	string => $string_regex
	regex => $regex_regex
	variable => $variable_regex
	context_reference => $context_reference_regex
	function_reference => $function_reference_regex

	comment => $comment_regex
	whitespace => $whitespace_regex
}

# tokens that will get filtered off
ignored_tokens {
	comment
	whitespace
}

# context definitions
object context root {
	$identifier_regex, '=' {
		$_{'variables'}{$0} = !def_value
		# assign {
		# }
	}
	'package', $package_identifier_regex {
		$_{'package_identifier'} = $1
		# assign {
		# }
	}
	'tokens', '{' {
		$_{'tokens'} = !token_definition->[]
		# assign {
		# }
	}
	'ignored_tokens', '{' {
		$_{'ignored_tokens'} = !ignored_tokens_list->[]
		# assign {
		# }
	}
	'item', 'context', $identifier_regex, '{' {
		$_{'item_contexts'}{$2} = !context_definition->[]
		# assign {
		# }
	}
	'list', 'context', $identifier_regex, '{' {
		$_{'list_contexts'}{$2} = !context_definition->[]
		# assign {
		# }
	}
	'object', 'context', $identifier_regex, '{' {
		$_{'object_contexts'}{$2} = !context_definition->[]
		# assign {
		# }
	}
}

item context def_value {
	$string_regex {
		$_ = $0
		return
	}
	$regex_regex {
		$_ = $0
		return
	}
	$variable_regex {
		$_ = $0
		return
	}
	default {
		die 'unexpected token in def_value'
	}
}

list context token_definition {
	'}' {
		return
	}
	$identifier_regex, '=>' {
		push $0
		push !def_value
	}
	default {
		die 'unexpected token in token_definition'
	}
}

list context ignored_tokens_list {
	'}' {
		return
	}
	$identifier_regex {
		push $0
	}
	default {
		die 'unexpected token in ignored_tokens_list'
	}
}

list context context_definition {
	'}' {
		return
	}
	'default', '{' {
		push undef
		push !match_action->[]
	}
	default {
		push !match_list->[]
		match '{'
		push !match_action->[]
	}
}

list context match_list {
	$variable_regex, ',' {
		push $0
	}
	$variable_regex {
		push $0
		return
	}
	$regex_regex, ',' {
		push $0
	}
	$regex_regex {
		push $0
		return
	}
	$string_regex, ',' {
		push $0
	}
	$string_regex {
		push $0
		return
	}
	default {
		die 'unexpected end of match list'
	}
}

list context match_action {
	# 'assign', '{' {
	# 	push 'assign'
	# 	push !assign_scope->[]
	# }
	'$_', '=' {
		push 'assign_item'
		push !spawn_expression
	}
	'$_', '{', $string_regex, '}', '{' {
		push 'assign_object_field'
		push $2
		push !spawn_expression
		match '}', '='
		push !spawn_expression
	}
	'$_', '{', $string_regex, '}', '[', ']', '=' {
		push 'assign_array_field'
		push $2
		push !spawn_expression
	}
	'$_', '{', $string_regex, '}', '=' {
		push 'assign_field'
		push $2
		push !spawn_expression
	}
	'push' {
		push 'push'
		push !spawn_expression
	}
	# 'respawn' {
	# 	push 'respawn'
	# 	push !spawn_expression
	# }
	'return' {
		push 'return'
	}
	'match' {
		push 'match'
		push !match_list->[]
	}
	'warn', $string_regex {
		push 'warn'
		push $1
	}
	'die', $string_regex {
		push 'die'
		push $1
	}
	'}' {
		return
	}
	default {
		die 'expected \'}\' to close match actions list'
	}
}

item context spawn_expression {
	/\$\d++/ {
		$_ = $0
		return
	}
	'$_' {
		$_ = $0
		return
	}
	'pop' {
		$_ = 'pop'
		return
	}
	$context_reference_regex, '->' {
		$_ = {
			$0 => !spawn_expression
		}
		return
	}
	$context_reference_regex {
		$_ = $0
		return
	}
	$function_reference_regex, '->' {
		$_ = {
			$0 => !spawn_expression
		}
		return
	}
	$function_reference_regex {
		$_ = $0
		return
	}
	$string_regex {
		$_ = $0
		return
	}
	'undef' {
		$_ = undef
		return
	}
	'[', ']' {
		$_ = []
		return
	}
	'{', '}' {
		$_ = {}
		return
	}
	# '[' {
	# 	$_ = !spawn_expression_list->[]
	# 	return
	# }
	'{' {
		$_ = !spawn_expression_hash->[]
		return
	}
	default {
		die 'push expression expected'
	}
}

list context spawn_expression_list {
	$context_reference_regex, ']' {
		push $0
		return
	}
	default {
		die 'push expression list expected'
	}
}

list context spawn_expression_hash {
	'}' {
		return
	}
	$variable_regex, '=>' {
		push $0
		push !spawn_expression
	}
	$string_regex, '=>' {
		push $0
		push !spawn_expression
	}
	default {
		die 'push expression hash pair expected'
	}
}

# list context assign_scope {
# 	$string_regex, '=>' {
# 		push $0
# 		push !spawn_expression
# 	}
# 	$string_regex, '[', ']', '=>' {
# 		push $0
# 		push []
# 		push !spawn_expression
# 	}
# 	$string_regex, '{' {
# 		push $0
# 		push {}
# 		push !spawn_expression
# 		match '}', '=>'
# 		push !spawn_expression
# 	}
# 	'}' {
# 		return
# 	}
# 	default {
# 		die 'assign expression expected'
# 	}
# }

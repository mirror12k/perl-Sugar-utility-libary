
# declare our class name
package example::JSONParser

# compile with ./Sugar/Lang/SugarGrammarCompiler.pm example/json_parser.sugar > example/JSONParser.pm



# define all of our parser tokens as regex
tokens {
	# all groups must be set to non-capturing with ?:
	string => /"(?:[^"\\]|\\["\\\/bfnrt])*"/s
	# order matters, as earlier tokens will be tested first before later ones
	identifier => /[a-zA-Z_][a-zA-Z0-9_]*+/
	symbol => /\{|\}|\[|\]|,|:/
	number => /-?(?:0|[1-9][0-9]*)(?:\.[0-9]+)?(?:[eE][\+\-]?[0-9]+)?/
	# standard regex flags are accepted
	whitespace => /\s++/s
}
# define which tokens get filtered off before syntax parsing
ignored_tokens {
	whitespace
}


# root sub must be defined
# it is the entry point to your syntax parser
object sub root {
	# parse a single json value, and return it
	return !json_value
}

# object sub json_value {
# 	string_value->value = *string
# 		| number_value->value = *number
# 		| boolean_value->value = /true|false/
# 		| 'null' null_value->value = undef
# 		| '[' list_value->value = !json_list->[] ']'
# 		| '{' object_value->value = !json_object->{} '}'
# 		| die 'expected json value'
# }

# list sub json_list {
# 	[ []=!json_value{value}
# 		@[ ',' []=!json_value{value} ] ]
# }

# object sub json_object {
# 	[ $key = *string ':' {$key} = !json_value{value}
# 		@[ ',' $key = *string ':' {$key} = !json_value{value} ] ]
# }

# things we need for this:
# - optional matching
# - loop-matching

# - immediate assignment
# - immediate list assignment: [] =
# - immediate object assignment: {$key} =
# - immediate typed-object assignment: string_value->value =
# - branch matching


# a sub which is meant to match a json value
object sub json_value {
	match string_value:{value} = *string
		| number_value:{value} = *number
		| boolean_value:{value} = /true|false/
		| 'null', null_value:{value} => undef
		| '[', ']', list_value:{value} => []
		| '[', list_value:{value} = !json_list->[], ']'
		| '{', '}', object_value:{value} => {}
		| '{', object_value:{value} = !json_object->{}, '}'
		| die 'expected json value'
	return
}
# object sub json_value =>
# 	string_value:{value} = *string
# 		| number_value:{value} = *number
# 		| boolean_value:{value} = /true|false/
# 		| 'null', null_value:{value} => undef
# 		| '[', ']', list_value:{value} => []
# 		| '[', list_value:{value} = !json_list->[], ']'
# 		| '{', '}', object_value:{value} => {}
# 		| '{', object_value:{value} = !json_object->{}, '}'
# 		| die 'expected json value'

list sub json_list {
	match [] = !json_value
	while ',', [] = !json_value => {}
	return
}

object sub json_object {
	match *string, ':', {$0} => !json_value
	while ',', *string, ':', {$3} => !json_value => {}
	return
}

